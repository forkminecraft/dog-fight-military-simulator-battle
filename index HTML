<!DOCTYPE html>
<html lang="en">
<head>
<meta charset="utf-8" />
<meta name="viewport" content="width=device-width,initial-scale=1" />
<title>Sky & Ground 3D — FPS Dogfight + Infantry (single file)</title>
<style>
  :root {
    color-scheme: dark;
    --bg: #0d0f12;
    --panel: rgba(16,18,22,0.85);
    --panelBorder: #212630;
    --accent: #40d3ff;
    --accent2: #86ff6b;
    --warn: #ff7a5a;
    --text: #e8eef7;
    --muted: #aab4c4;
  }
  html, body { margin: 0; padding: 0; height: 100%; background: var(--bg); color: var(--text);
    font-family: ui-sans-serif, system-ui, Segoe UI, Roboto, Helvetica, Arial; }
  #wrap { position: fixed; inset: 0; display: grid; grid-template-rows: 46px 1fr; }
  header { display:flex; align-items:center; justify-content:space-between; padding:0 12px; border-bottom:1px solid #1a1f27;
    background: linear-gradient(180deg,#11151b,#0d1015); }
  header .brand { font-weight: 700; color: #d8e6ff; letter-spacing: .3px; }
  header .hint { font-size:12px; color: var(--muted); }
  #viewport { position: relative; width: 100%; height: 100%; overflow: hidden; background: #000; }
  .panel {
    position: absolute; left: 50%; transform: translateX(-50%); max-width: 860px; width: calc(100% - 32px);
    padding: 16px; border-radius: 10px; border: 1px solid var(--panelBorder); background: var(--panel);
    box-shadow: 0 10px 40px rgba(0,0,0,0.35); backdrop-filter: blur(6px);
  }
  #menu { top: 72px; }
  #brief, #debrief, #paused { bottom: 28px; display:none; }
  h1,h2,h3 { margin: 0 0 8px; }
  .muted { color: var(--muted); }
  .row { display:flex; flex-wrap: wrap; gap: 8px; margin-top: 10px; }
  button { background: #171a20; color: #e6eefb; border: 1px solid #2a2f37; border-radius: 8px; padding: 10px 14px;
    font-weight: 600; letter-spacing: .2px; cursor: pointer; }
  button:hover { border-color: #39404b; background: #1c2129; }
  button.primary { background: linear-gradient(180deg,#213349,#1a2230); border-color: #2a415e; color: #e9f5ff; }
  .kbd { display:inline-block; border:1px solid #303844; border-bottom-width:2px; padding:3px 6px; border-radius:6px;
    background:#12151a; font-size:12px; margin:0 3px; color:#b5c3d9; }
  #hud { position:absolute; top:6px; left:6px; right:6px; display:flex; justify-content:space-between; pointer-events:none; }
  #hud .card { background: rgba(16,18,22,0.6); border: 1px solid #1d2129; border-radius: 8px; padding: 8px 10px; min-width: 220px; }
  #hud .title { font-size:12px; color: var(--muted); }
  #hud .big { font-size: 18px; font-weight: 800; letter-spacing: .6px; }
  #tip { position:absolute; bottom:8px; left:50%; transform: translateX(-50%); font-size:12px; color: var(--muted);
    background: rgba(16,18,22,0.6); border:1px solid #202632; border-radius:8px; padding:6px 10px; }
  #fact { position:absolute; right:10px; bottom:10px; max-width:440px; padding:10px 12px; border-radius:10px;
    background: rgba(10,14,20,0.75); border: 1px solid #1f2630; box-shadow: 0 8px 26px rgba(0,0,0,0.35); display:none; }
  #fact .lead { color:#cde6ff; font-weight:700; margin-bottom:4px; }
  #fact .body { color:#b8c7db; font-size:13px; }
  .ok { color: var(--accent2); }
  .warn { color: var(--warn); }
</style>
</head>
<body>
<div id="wrap">
  <header>
    <div class="brand">Sky & Ground 3D — FPS Dogfight + Infantry (prototype)</div>
    <div class="hint">Click the 3D view to lock mouse • Space/Click = Fire • Esc = Menu • P = Pause</div>
  </header>
  <div id="viewport"></div>

  <div id="menu" class="panel">
    <h2>Welcome, pilot.</h2>
    <div class="muted">3D prototype with air & ground, a short campaign, and instant skirmish. Click inside the view to aim.</div>
    <div class="row">
      <button class="primary" id="btnCampaign">Start campaign</button>
      <button id="btnSkirmishAir">Skirmish — Air</button>
      <button id="btnSkirmishGround">Skirmish — Ground</button>
    </div>
    <div style="margin-top:12px; font-size:13px;">
      Controls:
      <span class="kbd">Mouse</span> look,
      <span class="kbd">Space/Click</span> fire,
      <span class="kbd">Shift</span> boost/sprint,
      <span class="kbd">W/S</span> throttle/forward,
      <span class="kbd">A/D</span> yaw/strafe,
      <span class="kbd">Q/E</span> roll (air),
      <span class="kbd">P</span> pause.
    </div>
  </div>

  <div id="brief" class="panel">
    <h3 id="briefTitle">Briefing</h3>
    <div id="briefText" class="muted"></div>
    <div class="row"><button class="primary" id="btnLaunch">Launch mission</button><button id="btnBack">Back</button></div>
  </div>

  <div id="debrief" class="panel">
    <h3 id="debriefTitle">Debrief</h3>
    <div id="debriefText" class="muted"></div>
    <div class="row"><button class="primary" id="btnNext">Continue</button><button id="btnMenu">Main menu</button></div>
  </div>

  <div id="paused" class="panel">
    <h3>Paused</h3>
    <div class="muted">Press P to resume or Esc for menu.</div>
    <div class="row"><button class="primary" id="btnResume">Resume</button><button id="btnGoMenu">Main menu</button></div>
  </div>

  <div id="hud">
    <div class="card">
      <div class="title">Mode</div>
      <div id="hudMode" class="big">—</div>
      <div class="title">Objective</div>
      <div id="hudObj">—</div>
    </div>
    <div class="card">
      <div class="title">Status</div>
      <div id="hudStatus" class="big">—</div>
      <div class="title">Info</div>
      <div id="hudInfo">—</div>
    </div>
  </div>

  <div id="fact">
    <div class="lead">Fact</div>
    <div class="body" id="factBody">—</div>
  </div>

  <div id="tip">Click the 3D view to lock mouse • Space/Click = Fire</div>
</div>

<script type="module">
/* Minimal single-file 3D using Three.js (ESM from CDN) */
import * as THREE from 'https://unpkg.com/three@0.160.0/build/three.module.js';

const viewport = document.getElementById('viewport');

/* Renderer */
const renderer = new THREE.WebGLRenderer({ antialias: true, alpha: false });
renderer.setPixelRatio(Math.min(2, window.devicePixelRatio || 1));
renderer.setSize(viewport.clientWidth, viewport.clientHeight);
renderer.outputColorSpace = THREE.SRGBColorSpace;
viewport.appendChild(renderer.domElement);

/* Scene & camera */
const scene = new THREE.Scene();
scene.background = new THREE.Color(0x0b0f16);
scene.fog = new THREE.Fog(0x0b0f16, 180, 900);

const camera = new THREE.PerspectiveCamera(75, viewport.clientWidth / viewport.clientHeight, 0.1, 2000);
camera.position.set(0, 6, 12);

/* Lighting */
const hemi = new THREE.HemisphereLight(0xbcd7ff, 0x223344, 0.6);
scene.add(hemi);
const dir = new THREE.DirectionalLight(0xffffff, 0.8);
dir.position.set(120, 200, 80);
dir.castShadow = false;
scene.add(dir);

/* Ground & sky hints */
const grid = new THREE.GridHelper(4000, 80, 0x2f3440, 0x1f2430);
grid.position.y = 0;
scene.add(grid);
const horizon = new THREE.Mesh(
  new THREE.CylinderGeometry(900, 900, 2, 32, 1, true),
  new THREE.MeshBasicMaterial({ color: 0x101521, side: THREE.BackSide, transparent: true, opacity: 0.25 })
);
horizon.position.y = 1;
scene.add(horizon);

/* Materials & geometry pools */
const matEnemyAir = new THREE.MeshStandardMaterial({ color: 0x8fd0ff, metalness: 0.2, roughness: 0.6 });
const matEnemyGround = new THREE.MeshStandardMaterial({ color: 0xffb59c, metalness: 0.1, roughness: 0.8 });
const matPickup = new THREE.MeshStandardMaterial({ color: 0x86ff6b, emissive: 0x224422, emissiveIntensity: 0.4 });
const matBullet = new THREE.MeshBasicMaterial({ color: 0xffd38f });
const matPlayer = new THREE.MeshStandardMaterial({ color: 0x9fe6ff, metalness: 0.1, roughness: 0.8 });

const geoPlane = new THREE.ConeGeometry(1.2, 3.2, 12);
const geoSoldier = new THREE.CapsuleGeometry(0.5, 1.0, 4, 8);
const geoPickup = new THREE.BoxGeometry(0.8, 0.8, 0.8);
const geoBullet = new THREE.SphereGeometry(0.08, 8, 8);

/* UI refs */
const menu = document.getElementById('menu');
const brief = document.getElementById('brief');
const debrief = document.getElementById('debrief');
const pausedPanel = document.getElementById('paused');
const hudMode = document.getElementById('hudMode');
const hudObj = document.getElementById('hudObj');
const hudStatus = document.getElementById('hudStatus');
const hudInfo = document.getElementById('hudInfo');
const factBox = document.getElementById('fact');
const factBody = document.getElementById('factBody');

const ui = {
  show(el){ el.style.display = ''; },
  hide(el){ el.style.display = 'none'; },
  setBrief(title, text) {
    document.getElementById('briefTitle').textContent = title;
    document.getElementById('briefText').textContent = text;
  },
  setDebrief(title, text) {
    document.getElementById('debriefTitle').textContent = title;
    document.getElementById('debriefText').textContent = text;
  },
  setFact(text) {
    factBody.textContent = text;
    factBox.style.display = '';
    clearTimeout(ui._factT);
    ui._factT = setTimeout(()=> factBox.style.display = 'none', 9000);
  }
};

/* Input */
const keys = new Set();
let mouseLocked = false;
let yaw = 0, pitch = 0, roll = 0;
let pointerLook = { sens: 0.0022 };
let lastFire = 0;

function onKeyDown(e){
  if (e.repeat) return;
  keys.add(e.code);
  if (e.code === 'Escape') {
    document.exitPointerLock?.();
    if (game.state.inGame) toMenu();
  }
  if (e.code === 'KeyP' && game.state.inGame) {
    game.state.paused = !game.state.paused;
    pausedPanel.style.display = game.state.paused ? '' : 'none';
  }
}
function onKeyUp(e){ keys.delete(e.code); }
window.addEventListener('keydown', onKeyDown);
window.addEventListener('keyup', onKeyUp);

renderer.domElement.addEventListener('click', () => {
  renderer.domElement.requestPointerLock?.();
});
document.addEventListener('pointerlockchange', () => {
  mouseLocked = (document.pointerLockElement === renderer.domElement);
});
document.addEventListener('mousemove', (e) => {
  if (!mouseLocked || game.state.paused) return;
  const s = pointerLook.sens;
  yaw += e.movementX * s;
  pitch += -e.movementY * s * 0.7;
  pitch = Math.max(-Math.PI/2 + 0.05, Math.min(Math.PI/2 - 0.05, pitch));
});

/* World & game state */
const RAND = {
  rng: Math.random,
  range(a,b){ return a + (b-a)*this.rng(); },
  int(a,b){ return Math.floor(this.range(a,b+1)); },
  choice(arr){ return arr[this.int(0, arr.length-1)]; }
};
const tempV = new THREE.Vector3();
const up = new THREE.Vector3(0,1,0);

const world = {
  enemies: [],  // {type:'plane'|'soldier', mesh, hp, t}
  pickups: [],  // {mesh}
  bullets: [],  // {mesh, vel, life, from:'player'|'enemy'}
  particles: [],// not used in this minimal pass
  time: 0
};

const player = {
  mode: 'air', // 'air'|'ground'
  hp: 100,
  score: 0,
  throttle: 0.6, // 0..1
  speedAirMin: 40,
  speedAirMax: 180,
  afterburn: 0,
  eyeHeight: 1.6,
  pos: new THREE.Vector3(0, 50, 0),
  vel: new THREE.Vector3(),
  onGround: false
};

const game = {
  state: {
    inGame: false,
    paused: false,
    scenario: 'skirmish',
    objective: null,
    kills: 0,
    pickups: 0,
    difficulty: 1
  },
  campaignIndex: 0
};

/* Campaign content */
const facts = [
  "Pilots wear anti‑G suits to reduce G‑LOC (G‑induced loss of consciousness) in high‑G turns.",
  "Chaff confuses radar seekers; flares decoy many infrared seekers. Timing matters more than quantity.",
  "IFF (Identification Friend or Foe) helps reduce fratricide but can be spoofed or fail; visual ID remains important.",
  "BVR (Beyond‑Visual‑Range) uses sensors and datalinks; WVR (Within‑Visual‑Range) can come down to helmet sights and the gun."
];
const missions = [
  {
    title: "Mission 1 — Quiet Skies",
    mode: "air",
    briefing: "Routine CAP over coastal airspace. ROE: PID and engage hostile bandits. Expect a light intercept.",
    objective: { kills: 3 },
    twist: "Mid‑sortie: One contact flags friendly on IFF inside the enemy group. Possible spoofing or captured transponder.",
    fact: facts[2]
  },
  {
    title: "Mission 2 — Broken Signal",
    mode: "ground",
    briefing: "Secure a downed drone’s canister. Expect light patrols. Move before QRF arrives.",
    objective: { pickups: 1, kills: 3 },
    twist: "The wreck is a decoy. Telemetry relayed from a nearby node—ambush risk increased.",
    fact: facts[1]
  },
  {
    title: "Mission 3 — False Echoes",
    mode: "air",
    briefing: "Scramble: raid vectoring on base. Unknowns are IFF‑masking intermittently. Protect the field.",
    objective: { kills: 5 },
    twist: "Insider compromise suspected. Wingman diverts to escort evac helos—clear their lane.",
    fact: facts[3]
  }
];

/* Helpers */
function resize(){
  const w = viewport.clientWidth, h = viewport.clientHeight;
  renderer.setPixelRatio(Math.min(2, window.devicePixelRatio || 1));
  renderer.setSize(w, h, false);
  camera.aspect = w / h;
  camera.updateProjectionMatrix();
}
window.addEventListener('resize', resize);
setTimeout(resize, 0);

function clearWorld(){
  for (const e of world.enemies) scene.remove(e.mesh);
  for (const p of world.pickups) scene.remove(p.mesh);
  for (const b of world.bullets) scene.remove(b.mesh);
  world.enemies.length = 0;
  world.pickups.length = 0;
  world.bullets.length = 0;
}

function clamp(v, a, b){ return Math.max(a, Math.min(b, v)); }
function lerp(a,b,t){ return a + (b-a)*t; }

/* Spawning */
function spawnEnemy(type, where='ahead'){
  const mesh = new THREE.Mesh(type==='plane'? geoPlane: geoSoldier, type==='plane'? matEnemyAir: matEnemyGround);
  mesh.castShadow = false; mesh.receiveShadow = false;
  let pos = new THREE.Vector3();
  if (type==='plane'){
    const dist = RAND.range(150, 350);
    const ang = yaw + RAND.range(-0.8, 0.8);
    pos.set(Math.sin(ang)*dist, RAND.range(40, 160), Math.cos(ang)*dist);
    mesh.rotation.x = Math.PI/2;
    mesh.scale.setScalar(1.3);
  } else {
    const dist = RAND.range(40, 120);
    const ang = yaw + RAND.range(-0.8, 0.8);
    pos.set(Math.sin(ang)*dist, 0, Math.cos(ang)*dist);
    mesh.scale.setScalar(1.0);
  }
  mesh.position.copy(player.pos).add(pos);
  scene.add(mesh);
  world.enemies.push({ type, mesh, hp: type==='plane'? 45 : 25, t: 0 });
}

function spawnPickup(){
  const cube = new THREE.Mesh(geoPickup, matPickup);
  const dist = RAND.range(30, 100);
  const ang = yaw + RAND.range(-0.6, 0.6);
  const pos = new THREE.Vector3(Math.sin(ang)*dist, 0.4, Math.cos(ang)*dist).add(player.pos);
  cube.position.copy(pos);
  cube.rotation.set(0.4, 0.6, 0.1);
  scene.add(cube);
  world.pickups.push({ mesh: cube });
}

function fireBullet(fromPlayer=true){
  const now = performance.now();
  const cd = player.mode==='air' ? 80 : 120; // ms
  if (fromPlayer && (now - lastFire) < cd) return;
  lastFire = now;

  const bullet = new THREE.Mesh(geoBullet, matBullet);
  const muzzle = camera.position.clone();
  const dirVec = new THREE.Vector3(0,0,-1).applyQuaternion(camera.quaternion).normalize();
  const spread = (player.mode==='air'? 0.003 : 0.006);
  dirVec.x += RAND.range(-spread, spread);
  dirVec.y += RAND.range(-spread, spread);
  dirVec.z += RAND.range(-spread, spread);
  dirVec.normalize();

  bullet.position.copy(muzzle).addScaledVector(dirVec, 1.2);
  scene.add(bullet);
  const speed = 280 + (player.mode==='air'? (player.throttle*(player.speedAirMax-player.speedAirMin))*0.3 : 0);
  world.bullets.push({ mesh: bullet, vel: dirVec.multiplyScalar(speed), life: 1.2, from: fromPlayer? 'player':'enemy' });
}

/* Modes setup */
function resetWorld(mode){
  clearWorld();
  player.mode = mode;
  player.hp = 100;
  player.score = 0;
  player.throttle = (mode==='air') ? 0.6 : 0.0;
  player.afterburn = 0;
  player.vel.set(0,0,0);
  yaw = 0; pitch = 0; roll = 0;
  player.pos.set( RAND.range(-20,20), mode==='air'? RAND.range(40,80): 1.6, RAND.range(-20,20) );
  camera.position.copy(player.pos);

  // Seed enemies
  const count = 4;
  for (let i=0;i<count;i++) spawnEnemy(mode==='air'? 'plane':'soldier');
  if (mode==='ground') spawnPickup();
}

/* UI flow */
function toMenu(){
  game.state.inGame = false;
  game.state.paused = false;
  ui.show(menu);
  ui.hide(brief);
  ui.hide(debrief);
  pausedPanel.style.display = 'none';
}

function startSkirmish(mode){
  ui.hide(menu); ui.hide(brief); ui.hide(debrief);
  resetWorld(mode);
  game.state.inGame = true;
  game.state.scenario = 'skirmish';
  game.state.objective = { text: 'Survive & score' };
  factBox.style.display = 'none';
}

function startCampaign(){
  game.campaignIndex = 0;
  showBrief();
}

function showBrief(){
  const m = missions[game.campaignIndex];
  if (!m){ toMenu(); return; }
  ui.hide(menu); ui.hide(debrief);
  ui.setBrief(m.title, m.briefing);
  ui.show(brief);
  factBox.style.display = 'none';
}

function startMission(){
  const m = missions[game.campaignIndex];
  resetWorld(m.mode);
  game.state.inGame = true;
  game.state.scenario = 'campaign';
  game.state.objective = m.objective;
  ui.hide(brief);
  if (m.fact) ui.setFact(m.fact);
}

function completeMission(win){
  game.state.inGame = false;
  const m = missions[game.campaignIndex];
  const text = win
    ? `${m.title} complete. Twist: ${m.twist}`
    : `${m.title} failed. You can retry or return to menu.`;
  ui.setDebrief(win? 'Mission complete' : 'Mission failed', text);
  ui.show(debrief);
}

function nextMissionOrEnd(){
  game.campaignIndex++;
  if (game.campaignIndex >= missions.length){
    ui.setDebrief('Campaign complete', 'You held the line in the air and on the ground. Debrief recommends tightening IFF procedures and counter‑spoofing drills.');
  } else {
    showBrief();
  }
}

/* Buttons */
document.getElementById('btnCampaign').onclick = startCampaign;
document.getElementById('btnSkirmishAir').onclick = () => startSkirmish('air');
document.getElementById('btnSkirmishGround').onclick = () => startSkirmish('ground');
document.getElementById('btnLaunch').onclick = startMission;
document.getElementById('btnBack').onclick = toMenu;
document.getElementById('btnNext').onclick = nextMissionOrEnd;
document.getElementById('btnMenu').onclick = toMenu;
document.getElementById('btnResume').onclick = () => { game.state.paused = false; pausedPanel.style.display = 'none'; } ;
document.getElementById('btnGoMenu').onclick = toMenu;

/* Physics & AI */
function updatePlayer(dt){
  const dtSec = dt;
  if (player.mode === 'air'){
    // Inputs
    if (keys.has('KeyW')) player.throttle = clamp(player.throttle + 0.5*dtSec, 0, 1);
    if (keys.has('KeyS')) player.throttle = clamp(player.throttle - 0.5*dtSec, 0, 1);
    const yawRate = 1.5, pitchRate = 1.5, rollRate = 1.8;
    if (keys.has('KeyA')) yaw += yawRate * dtSec;
    if (keys.has('KeyD')) yaw -= yawRate * dtSec;
    if (keys.has('KeyQ')) roll += rollRate * dtSec;
    if (keys.has('KeyE')) roll -= rollRate * dtSec;
    if (keys.has('ShiftLeft') || keys.has('ShiftRight')) player.afterburn = clamp(player.afterburn + dtSec*1.5, 0, 0.35);
    else player.afterburn = clamp(player.afterburn - dtSec*1.2, 0, 0.35);

    // Speed
    const sp = lerp(player.speedAirMin, player.speedAirMax*(1+player.afterburn), player.throttle);
    // Forward vector from yaw/pitch
    const q = new THREE.Quaternion().setFromEuler(new THREE.Euler(pitch, yaw, roll, 'YXZ'));
    const fwd = new THREE.Vector3(0,0,-1).applyQuaternion(q).normalize();
    // Gentle auto-level roll if no roll input
    if (!keys.has('KeyQ') && !keys.has('KeyE')) roll = lerp(roll, 0, 0.6*dtSec);
    // Update velocity and position
    player.vel.copy(fwd).multiplyScalar(sp);
    player.pos.addScaledVector(player.vel, dtSec);
    // Ground collision
    if (player.pos.y < 5){ player.pos.y = 5; pitch = Math.max(pitch, -0.2); }
    // Camera follow
    camera.quaternion.copy(q);
    camera.position.copy(player.pos);
  } else {
    // Ground mode
    const move = new THREE.Vector3();
    const moveSpeed = (keys.has('ShiftLeft')||keys.has('ShiftRight')) ? 10 : 6.5;
    const walkYaw = yaw;
    const cos = Math.cos(walkYaw), sin = Math.sin(walkYaw);
    const fwd = new THREE.Vector3(sin, 0, cos).multiplyScalar(moveSpeed);
    const right = new THREE.Vector3(cos, 0, -sin).multiplyScalar(moveSpeed);
    if (keys.has('KeyW')) move.add(fwd);
    if (keys.has('KeyS')) move.addScaledVector(fwd, -1);
    if (keys.has('KeyA')) move.addScaledVector(right, -1);
    if (keys.has('KeyD')) move.add(right);
    // Jump tap
    if (keys.has('Space') && player.onGround){ player.vel.y = 7.5; player.onGround = false; }
    // Gravity
    player.vel.y += -20 * dtSec;
    // Integrate
    player.pos.addScaledVector(move, dtSec);
    player.pos.y += player.vel.y * dtSec;
    if (player.pos.y <= player.eyeHeight){
      player.pos.y = player.eyeHeight;
      player.vel.y = 0;
      player.onGround = true;
    }
    // Camera
    const q = new THREE.Quaternion().setFromEuler(new THREE.Euler(pitch, yaw, 0, 'YXZ'));
    camera.position.copy(player.pos);
    camera.quaternion.copy(q);
  }
}

function updateEnemies(dt){
  for (let i=world.enemies.length-1;i>=0;i--){
    const e = world.enemies[i];
    e.t += dt;
    const m = e.mesh;
    if (e.type==='plane'){
      // Circle the player at roughly constant altitude
      const dirToPlayer = tempV.copy(player.pos).sub(m.position);
      const dist = dirToPlayer.length();
      const orbitSpeed = clamp(70 + (200 - dist)*0.
